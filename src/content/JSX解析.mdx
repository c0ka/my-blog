## JSX 解析
JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。

### 使用 JSX 的语法

```javascript
function Layout({children}) {
  return <div className="layout-component">{children}</div>
}

function Hi(props) {
  return <div>Hi {props.name}, my buddy!</div>;
}

const App = () => {
	return (
  	 <Layout>
      <div>try this</div>
      <Hi name="julian"/>
     </Layout>)
}
```

### Babel 转译输出结果
函数式组件就是普通的 js 函数，接受 props（对象） 参数。 
props 参数在函数返回的 React 元素中使用时，也是createElement函数调用的 children参数的一部分。

使用组件就是函数调用，
props.children 是组件被调用时传入的子组件。

```javascript
function Layout({
  children
}) {
  return /*#__PURE__*/React.createElement("div", {
    className: "layout-component"
  }, children);
}

function Hi(props) {
  return /*#__PURE__*/React.createElement("div", null, "Hi ", props.name, ", my buddy!");
}

const App = () => {
  return /*#__PURE__*/React.createElement(
      Layout, 
      null, 
      /*#__PURE__*/React.createElement("div", null, "try this"), 
      /*#__PURE__*/React.createElement(Hi, {name: "julian"})
  );
};
```

### React.createElement 源码
```javascript
/**
   * Create and return a new ReactElement of the given type.
   * See https://reactjs.org/docs/react-api.html#createelement
   */

  function createElement(type, config, children) {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) {
      if (hasValidRef(config)) {
        ref = config.ref;

        {
          warnIfStringRefCannotBeAutoConverted(config);
        }
      }

      if (hasValidKey(config)) {
        key = '' + config.key;
      }

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

      for (propName in config) {
        if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    } // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }

      {
        if (Object.freeze) {
          Object.freeze(childArray);
        }
      }

      props.children = childArray;
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    {
      if (key || ref) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }

        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
```